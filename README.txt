CS214 P2 - Spelling Checker

    - Vineet Bogam (vb422) and Karen Pedri (klp203)

Key Design Notes:

    - In order to implement our spelling checker program, we decided to utilize three different arraylists to extract 
        values from the provided text files/directories in the arguments. We opted to use arraylists instead of 
        fixed arrays because of its ability to reallocate memory, preventing segmentation faults 
        (there would be heap issues if we run out of memory using a fixed array) as well as increasing efficency. 

        - One arraylist stores dictionary word objects, which are structs that hold the original dictionary word, 
            as well as it's fully lowercase counterpart. For example, if a word in the dictionary word is "Doctor", 
            the dictionary struct will hold "Doctor", as well as "doctor". This is essential for code modularity and
            minimizing repetitions, as it prevents the necessity for unnecessary code in our binary search method.

            - After reading in the dictionary words, our population method also uses quick-sort on its respective 
                arraylist, ensuring that the dictionary is always sorted in ASCII order. This confirms that there 
                will be no errors with binary search iteration. 

        - The second arraylist stores the names of the text files collected in the second argument, where our 
            populate_txt() method traverses the directory provided in the second argument (through a recursive directory 
            traversal), getting all the names of the txt files for future use. 
        
        - The third arraylist stores word objects, which holds the word read from the text file, as well as its respective
            line and column number in the text file. These words are generated by reading through the txt_files arraylist. 
            The inclusion of line and column number in the struct are helpful for reporting errors.
    
    - We decided to check the spelling of all collected words by binary searching the dictionary array, due to its 
        efficiency (O(logn)) and decreased memory usage. Our function first works by comparing the dictionary and 
        selected input word without case-sensitivity. If both are equal at this point, it will check the input word 
        against the original dictionary word (with original cases) and returns if they are a match based on the 
        capitalization rules highlighted in the write-up. Helper functions such as allcaps() are used here for clearness.

        - strcmp(), isalpha(), islower() and isupper() are ctype functions that we decided to use to compare words. These
            functions were essential because of the ease of comparing ASCII based values. 

        - If hyphens are present in a word, we use checkHyphens() and splitHyphens() to split the hyphenated words into
            smaller instances, pushing them into an words array and then traversing that array seperately. Binary search is 
            performed on every non-null word object in that array. An arraylist here was not essential, as hyphenated words
            are not typically large in nature. 

General Design Notes: 

    - To ensure that no memory leaks occur, we created a clearwords() method instead of overwriting previous input (which is 
    executed after every text file is finished), as well as certified that directories were closed with closeddir(). 

    - In addition, input is read with a buffer size of 16 for every line in the text file

    - Numbers and other regex punctuation are discarded if they are trailing or occuring before a inputted word

    - We also used a #ifndef macro to debug code with print statements more efficiently

    - a makefile is used to easily parse the directory using the command "make test"

Library Requirements:
  
    - two arguments need to be provided for proper input, where the first has to be a textfile and the next has to
         be a directory/text file
    - provided input files needs to consist of at least one word of all alphabetic characters
    - The maximum length of a word cannot exceed 100 characters
        - The number of words strung together by hyphens can also not exceed 100
    
Test Scenarios:

    - To ensure correctness, we tested the following: 
        - a word with be accepted if its corresponding dictionary word is lowercase AND
            only its first letter is capital OR all letters are capital OR all letters are lowercase
        - a word with only be accepted if its corresponding dictionary word is uppercase IF
            all it's letters are capital
        - apostrophes and hyphens are correctly read by the binary search 
        - words that contain non-trailing punctuation (not including apostophes and hyphens) 
            should always be rejected
        - can large text files be fully read and checked?
            - check if no segmentation faults occur or severe performance issues
        - if we are able to correctly collect all text files in the directory

Test Cases:

    - basictests.txt: 
        - Evaluates basic punctuation, apostrophe, and capitalization handling
        - Checks if trailing and leading punctuation does not affect the inputted word
        - Checks that numbers are treated as punctuation
    
    - nestedtest
        - nestedtest is a directory that contains a directory called extratest and a nestedtxt.txt file
            - extratest contains an extratest.txt file
        - this tests if directories are properly parsed and all words in the nested files are read and checked

    - segCheck.txt (will add after arraylist implementation)
        - checks if the program can successfully read and check a large file without memory issues
